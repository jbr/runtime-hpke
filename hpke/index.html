<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="hpke"><title>hpke - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-42caa33d.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="hpke" data-themes="" data-resource-suffix="" data-rustdoc-version="1.84.1 (e71f9a9a9 2025-01-27)" data-channel="1.84.1" data-search-js="search-92e6798f.js" data-settings-js="settings-0f613d39.js" ><script src="../static.files/storage-59e33391.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../hpke/index.html">hpke</a><span class="version">0.12.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#hpke" title="hpke">hpke</a></li></ul><h3><a href="#reexports">Crate Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>hpke</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/hpke/lib.rs.html#1-222">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="hpke"><a class="doc-anchor" href="#hpke">§</a>hpke</h2>
<p><strong>WARNING:</strong> This code has not been audited. Use at your own discretion.</p>
<p>This is a pure Rust implementation of the
<a href="https://datatracker.ietf.org/doc/rfc9180/">HPKE</a> hybrid encryption scheme (RFC 9180). The
purpose of hybrid encryption is to use allow someone to send secure messages to an entity whose
public key they know. Here’s an example of Alice and Bob, where Alice knows Bob’s public key:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// These types define the ciphersuite Alice and Bob will be using
</span><span class="kw">type </span>Kem = X25519HkdfSha256;
<span class="kw">type </span>Aead = ChaCha20Poly1305;
<span class="kw">type </span>Kdf = HkdfSha384;

<span class="kw">let </span><span class="kw-2">mut </span>csprng = StdRng::from_entropy();

<span class="comment">// This is a description string for the session. Both Alice and Bob need to know this value.
// It's not secret.
</span><span class="kw">let </span>info_str = <span class="string">b"Alice and Bob's weekly chat"</span>;

<span class="comment">// Alice initiates a session with Bob. OpModeS::Base means that Alice is not authenticating
// herself at all. If she had a public key herself, or a pre-shared secret that Bob also
// knew, she'd be able to authenticate herself. See the OpModeS and OpModeR types for more
// detail.
</span><span class="kw">let </span>(encapsulated_key, <span class="kw-2">mut </span>encryption_context) =
    hpke::setup_sender::&lt;Aead, Kdf, Kem, <span class="kw">_</span>&gt;(<span class="kw-2">&amp;</span>OpModeS::Base, <span class="kw-2">&amp;</span>bob_pk, info_str, <span class="kw-2">&amp;mut </span>csprng)
        .expect(<span class="string">"invalid server pubkey!"</span>);

<span class="comment">// Alice encrypts a message to Bob. `aad` is authenticated associated data that is not
// encrypted.
</span><span class="kw">let </span>msg = <span class="string">b"fronthand or backhand?"</span>;
<span class="kw">let </span>aad = <span class="string">b"a gentleman's game"</span>;
<span class="comment">// To seal without allocating:
//     let auth_tag = encryption_context.seal_in_place_detached(&amp;mut msg, aad)?;
// To seal with allocating:
</span><span class="kw">let </span>ciphertext = encryption_context.seal(msg, aad).expect(<span class="string">"encryption failed!"</span>);

<span class="comment">// ~~~
// Alice sends the encapsulated key, message ciphertext, AAD, and auth tag to Bob over the
// internet. Alice doesn't care if it's an insecure connection, because only Bob can read
// her ciphertext.
// ~~~

// Somewhere far away, Bob receives the data and makes a decryption session
</span><span class="kw">let </span><span class="kw-2">mut </span>decryption_context =
    hpke::setup_receiver::&lt;Aead, Kdf, Kem&gt;(
        <span class="kw-2">&amp;</span>OpModeR::Base,
        <span class="kw-2">&amp;</span>bob_sk,
        <span class="kw-2">&amp;</span>encapsulated_key,
        info_str,
    ).expect(<span class="string">"failed to set up receiver!"</span>);
<span class="comment">// To open without allocating:
//     decryption_context.open_in_place_detached(&amp;mut ciphertext, aad, &amp;auth_tag)
// To open with allocating:
</span><span class="kw">let </span>plaintext = decryption_context.open(<span class="kw-2">&amp;</span>ciphertext, aad).expect(<span class="string">"invalid ciphertext!"</span>);

<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>plaintext, <span class="string">b"fronthand or backhand?"</span>);</code></pre></div>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.generic_array"><code>pub use <a class="mod" href="../generic_array/index.html" title="mod generic_array">generic_array</a>;</code></div></li><li><div class="item-name" id="reexport.rand_core"><code>pub use <a class="mod" href="../rand_core/index.html" title="mod rand_core">rand_core</a>;</code></div></li></ul><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="aead/index.html" title="mod hpke::aead">aead</a></div><div class="desc docblock-short">Traits and structs for authenticated encryption schemes</div></li><li><div class="item-name"><a class="mod" href="kdf/index.html" title="mod hpke::kdf">kdf</a></div><div class="desc docblock-short">Traits and structs for key derivation functions</div></li><li><div class="item-name"><a class="mod" href="kem/index.html" title="mod hpke::kem">kem</a></div><div class="desc docblock-short">Traits and structs for key encapsulation mechanisms</div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.PskBundle.html" title="struct hpke::PskBundle">PskBundle</a></div><div class="desc docblock-short">Contains preshared key bytes and an identifier. This is intended to go inside an <code>OpModeR</code> or
<code>OpModeS</code> struct.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.HpkeError.html" title="enum hpke::HpkeError">Hpke<wbr>Error</a></div><div class="desc docblock-short">Describes things that can go wrong in the HPKE protocol</div></li><li><div class="item-name"><a class="enum" href="enum.OpModeR.html" title="enum hpke::OpModeR">OpModeR</a></div><div class="desc docblock-short">The operation mode of the HPKE session (receiver’s view). This is how the sender authenticates
their identity to the receiver. This authentication information can include a preshared key,
the identity key of the sender, both, or neither. <code>Base</code> is the only mode that does not provide
any kind of sender identity authentication.</div></li><li><div class="item-name"><a class="enum" href="enum.OpModeS.html" title="enum hpke::OpModeS">OpModeS</a></div><div class="desc docblock-short">The operation mode of the HPKE session (sender’s view). This is how the sender authenticates
their identity to the receiver. This authentication information can include a preshared key,
the identity key of the sender, both, or neither. <code>Base</code> is the only mode that does not provide
any kind of sender identity authentication.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Deserializable.html" title="trait hpke::Deserializable">Deserializable</a></div><div class="desc docblock-short">Implemented by types that can be deserialized from byte representation</div></li><li><div class="item-name"><a class="trait" href="trait.Kem.html" title="trait hpke::Kem">Kem</a></div><div class="desc docblock-short">Represents authenticated encryption functionality</div></li><li><div class="item-name"><a class="trait" href="trait.Serializable.html" title="trait hpke::Serializable">Serializable</a></div><div class="desc docblock-short">Implemented by types that have a fixed-length byte representation</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.setup_receiver.html" title="fn hpke::setup_receiver">setup_<wbr>receiver</a></div><div class="desc docblock-short">Initiates a decryption context given a private key <code>sk_recip</code> and an encapsulated key which
was encapsulated to <code>sk_recip</code>’s corresponding public key</div></li><li><div class="item-name"><a class="fn" href="fn.setup_sender.html" title="fn hpke::setup_sender">setup_<wbr>sender</a></div><div class="desc docblock-short">Initiates an encryption context to the given recipient public key</div></li><li><div class="item-name"><a class="fn" href="fn.single_shot_open.html" title="fn hpke::single_shot_open">single_<wbr>shot_<wbr>open</a></div><div class="desc docblock-short">Does a <code>setup_receiver</code> and <code>AeadCtxR::open</code> in one shot. That is, it does a key decapsulation
for the specified recipient and decrypts the provided ciphertext. See <code>setup::setup_reciever</code>
and <code>AeadCtxR::open</code> for more detail.</div></li><li><div class="item-name"><a class="fn" href="fn.single_shot_open_in_place_detached.html" title="fn hpke::single_shot_open_in_place_detached">single_<wbr>shot_<wbr>open_<wbr>in_<wbr>place_<wbr>detached</a></div><div class="desc docblock-short">Does a <code>setup_receiver</code> and <code>AeadCtxR::open_in_place_detached</code> in one shot. That is, it does a
key decapsulation for the specified recipient and decrypts the provided ciphertext in place.
See <code>setup::setup_reciever</code> and <code>AeadCtxR::open_in_place_detached</code> for more detail.</div></li><li><div class="item-name"><a class="fn" href="fn.single_shot_seal.html" title="fn hpke::single_shot_seal">single_<wbr>shot_<wbr>seal</a></div><div class="desc docblock-short">Does a <code>setup_sender</code> and <code>AeadCtxS::seal</code> in one shot. That is, it does a key encapsulation to
the specified recipient and encrypts the provided plaintext. See <code>setup::setup_sender</code> and
<code>AeadCtxS::seal</code> for more detail.</div></li><li><div class="item-name"><a class="fn" href="fn.single_shot_seal_in_place_detached.html" title="fn hpke::single_shot_seal_in_place_detached">single_<wbr>shot_<wbr>seal_<wbr>in_<wbr>place_<wbr>detached</a></div><div class="desc docblock-short">Does a <code>setup_sender</code> and <code>AeadCtxS::seal_in_place_detached</code> in one shot. That is, it does a
key encapsulation to the specified recipient and encrypts the provided plaintext in place. See
<code>setup::setup_sender</code> and <code>AeadCtxS::seal_in_place_detached</code> for more detail.</div></li></ul></section></div></main></body></html>