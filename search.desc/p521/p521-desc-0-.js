searchState.loadedDescShard("p521", 0, "RustCrypto: NIST P-521 (secp521r1) elliptic curve\nElliptic curve point in affine coordinates.\nCompressed SEC1-encoded NIST P-521 curve point.\nNIST P-521 SEC1 encoded point.\nNIST P-521 field element serialized as bytes.\nNIST P-521 elliptic curve.\nNon-zero NIST P-521 scalar field element.\nMultiplicative identity.\nElliptic curve point in projective coordinates.\nNIST P-521 public key.\nScalars are elements in the finite field modulo <code>n</code>.\nNIST P-521 secret key.\n576-bit unsigned big integer.\nZero element.\nAdd elements.\nDouble element (add it to itself).\nElliptic Curve Diffie-Hellman (Ephemeral) Support.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a <code>Scalar</code> from a canonical big-endian representation.\nDecode <code>Scalar</code> from a big endian byte slice.\nConvert a <code>u64</code> into a <code>Scalar</code>.\nDecode <code>Scalar</code> from <code>U576</code> converting it into Montgomery form:\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCompute <code>Scalar</code> inversion: <code>1 / self</code>.\nDetermine if this <code>Scalar</code> is even in the SEC1 sense: …\nDetermine if this <code>Scalar</code> is odd in the SEC1 sense: …\nDetermine if this <code>Scalar</code> is zero.\nMultiply elements.\nNegate element.\nReturns <code>self^exp</code>, where <code>exp</code> is a little-endian integer …\nRight shifts the scalar.\nCompute modular square root.\nCompute modular square.\nSubtract elements.\nReturns the big-endian encoding of this <code>Scalar</code>.\nTranslate <code>Scalar</code> out of the Montgomery domain, returning a …\nNIST P-521 Ephemeral Diffie-Hellman Secret.\nShared secret value computed via ECDH key agreement.\nLow-level Elliptic Curve Diffie-Hellman (ECDH) function.")