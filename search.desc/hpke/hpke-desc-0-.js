searchState.loadedDescShard("hpke", 0, "hpke\nThe identity public key of the sender\nThe identity keypair of the sender\nBoth of the above\nBoth of the above\nNo extra information included\nNo extra information included\nDecapsulation failed\nImplemented by types that can be deserialized from byte …\nEncapsulation failed\nThe encapsulated key for this KEM. This is used by the …\nDescribes things that can go wrong in the HPKE protocol\nAn input isn’t the right length. First value is the …\nThe algorithm identifier for a KEM implementation\nThe KDF was asked to output too many bytes\nRepresents authenticated encryption functionality\nThe allowed number of message encryptions has been reached\nThe operation mode of the HPKE session (receiver’s …\nThe operation mode of the HPKE session (sender’s view). …\nAn error occurred while opening a ciphertext\nSerialized size in bytes\nThe key exchange’s private key type. If you want to …\nA preshared key known to the sender and receiver\nA preshared key known to the sender and receiver\nContains preshared key bytes and an identifier. This is …\nThe key exchange’s public key type. If you want to …\nAn error occured while sealing a plaintext\nImplemented by types that have a fixed-length byte …\nAn invalid input value was encountered\nTraits and structs for authenticated encryption schemes\nDeterministically derives a keypair from the given input …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerates a random keypair using the given RNG\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTraits and structs for key derivation functions\nTraits and structs for key encapsulation mechanisms\nThe preshared key\nA bytestring that uniquely identifies this PSK\nInitiates a decryption context given a private key <code>sk_recip</code>…\nInitiates an encryption context to the given recipient …\nDoes a <code>setup_receiver</code> and <code>AeadCtxR::open</code> in one shot. That …\nDoes a <code>setup_receiver</code> and <code>AeadCtxR::open_in_place_detached</code> …\nDoes a <code>setup_sender</code> and <code>AeadCtxS::seal</code> in one shot. That …\nDoes a <code>setup_sender</code> and <code>AeadCtxS::seal_in_place_detached</code> …\nReturns the size (in bytes) of this type when serialized\nComputes the public key of a given private key\nSerializes <code>self</code> to a new array\nSerializes <code>self</code> to the given slice. <code>buf</code> MUST have length …\nThe algorithm identifier for an AEAD implementation\nRepresents authenticated encryption functionality\nThe HPKE receiver’s context. This is what you use to <code>open</code>…\nThe HPKE senders’s context. This is what you use to <code>seal</code> …\nAn authenticated encryption tag\nThe implementation of AES-128-GCM\nThe implementation of AES-256-GCM\nThe implementation of ChaCha20-Poly1305\nAn inert underlying Aead implementation. The open/seal …\nAn AEAD which can <strong>only</strong> be used for its <code>export()</code> function. …\nFills a given buffer with secret bytes derived from this …\nFills a given buffer with secret bytes derived from this …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nOpens the given ciphertext and returns a plaintext\nDoes a “detached open in place”, meaning it overwrites …\nSeals the given plaintext and returns the ciphertext\nDoes a “detached seal in place”, meaning it overwrites …\nThe implementation of HKDF-SHA256\nThe implementation of HKDF-SHA384\nThe implementation of HKDF-SHA512\nThe algorithm identifier for a KDF implementation\nRepresents key derivation functionality\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRepresents DHKEM(P-256, HKDF-SHA256)\nRepresents DHKEM(P-384, HKDF-SHA384)\nRepresents DHKEM(P-521, HKDF-SHA512)\nThe encapsulated key for this KEM. This is used by the …\nThe algorithm identifier for a KEM implementation\nRepresents authenticated encryption functionality\nThe key exchange’s private key type. If you want to …\nThe key exchange’s public key type. If you want to …\nRepresents DHKEM(X25519, HKDF-SHA256)\nDeterministically derives a keypair from the given input …\nDeterministically derives a keypair from the given input …\nDeterministically derives a keypair from the given input …\nDeterministically derives a keypair from the given input …\nDeterministically derives a keypair from the given input …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerates a random keypair using the given RNG\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nComputes the public key of a given private key\nComputes the public key of a given private key\nComputes the public key of a given private key\nComputes the public key of a given private key\nComputes the public key of a given private key")